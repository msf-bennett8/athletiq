import React, { useState, useRef, useEffect, useCallback } from 'react';
import { View, StyleSheet, Alert, Animated, TouchableOpacity, Dimensions, Platform, ScrollView, Modal } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useDispatch, useSelector } from 'react-redux';
import { Button, TextInput, Text, Surface, RadioButton, HelperText, Avatar, IconButton, ProgressBar, Chip, Checkbox } from 'react-native-paper';
import { launchImageLibrary, launchCamera } from 'react-native-image-picker';
import Icon from 'react-native-vector-icons/MaterialIcons';
import { debounce } from 'lodash';
import { loginStart, loginSuccess, loginFailure } from '../../store/reducers/authReducer';
import AuthService from '../../services/AuthService';
import { COLORS } from '../../styles/colors';
import { SPACING } from '../../styles/layout';
import { TEXT_STYLES } from '../../styles/typography';
import { USER_TYPES } from '../../utils/constants';
import FirebaseService from '../../services/FirebaseService';
import AuthMethodSelection from '../../components/auth/AuthMethodSelection';
import NetworkStatus from '../../components/auth/NetworkStatus';
import useNetworkStatus from '../../hooks/useNetworkStatus';

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

const MultiStepRegisterScreen = ({ navigation }) => {
  const [currentStep, setCurrentStep] = useState(0);
  const [formData, setFormData] = useState({
    authMethod: null,
    firstName: '',
    lastName: '',
    email: '',
    username: '',
    phone: '',
    sport: '',
    userType: USER_TYPES.PLAYER,
    customRole: '',
    securityQuestion: '',
    securityAnswer: '',
    password: '',
    confirmPassword: '',
    profileImage: null,
    emailOptIn: false,
  });
  
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [errors, setErrors] = useState({});
  const [validFields, setValidFields] = useState({});
  const [showImageModal, setShowImageModal] = useState(false);
  const [isUsernameAutoGenerated, setIsUsernameAutoGenerated] = useState(false);
  const [passwordFocused, setPasswordFocused] = useState(false);
  const [confirmPasswordFocused, setConfirmPasswordFocused] = useState(false);
  const [validationLoading, setValidationLoading] = useState({});
  const [securityQuestionFocused, setSecurityQuestionFocused] = useState(false);
  const [securityAnswerFocused, setSecurityAnswerFocused] = useState(false);
  const [showSecurityQuestionModal, setShowSecurityQuestionModal] = useState(false);
  const [emailError, setEmailError] = useState(null);
  const [usernameError, setUsernameError] = useState(null);
  const [phoneError, setPhoneError] = useState(null);
  const [emailValidating, setEmailValidating] = useState(false);
  const [usernameValidating, setUsernameValidating] = useState(false);
  const [phoneValidating, setPhoneValidating] = useState(false);

  const networkStatus = useNetworkStatus();

  const slideAnim = useRef(new Animated.Value(0)).current;
  const dispatch = useDispatch();
  const { loading } = useSelector(state => state.auth);

    const cleanupExistingDuplicates = async () => {
    try {
      const registeredUsersJson = await AsyncStorage.getItem('registeredUsers');
      if (registeredUsersJson) {
        const users = JSON.parse(registeredUsersJson);
        
        // Remove duplicates based on email (keep the most recent)
        const uniqueUsers = users.filter((user, index, array) => {
          const lastIndex = array.map(u => u.email.toLowerCase()).lastIndexOf(user.email.toLowerCase());
          return index === lastIndex;
        });
        
        if (uniqueUsers.length !== users.length) {
          console.log(`Cleaned up ${users.length - uniqueUsers.length} duplicate users`);
          await AsyncStorage.setItem('registeredUsers', JSON.stringify(uniqueUsers));
        }
      }
    } catch (error) {
      console.error('Error cleaning duplicates:', error);
    }
  };

  // Debounced validation functions
const validateEmailDebounced = useCallback(
  debounce(async (email) => {
    if (!email || email.length < 5 || !email.includes('@')) {
      setEmailError(null);
      setEmailValidating(false);
      return;
    }

    setEmailValidating(true);
    
    try {
      const FirebaseService = (await import('../../services/FirebaseService')).default;
      const result = await FirebaseService.validateEmailAvailability(email);
      
      if (!result.available) {
        setEmailError(result.message);
      } else {
        setEmailError(null);
      }
    } catch (error) {
      console.error('Email validation error:', error);
      setEmailError(null);
    } finally {
      setEmailValidating(false);
    }
  }, 800),
  []
);

const validateUsernameDebounced = useCallback(
  debounce(async (username) => {
    if (!username || username.length < 3) {
      setUsernameError(null);
      setUsernameValidating(false);
      return;
    }

    setUsernameValidating(true);
    
    try {
      const FirebaseService = (await import('../../services/FirebaseService')).default;
      const result = await FirebaseService.validateUsernameAvailability(username);
      
      if (!result.available) {
        setUsernameError(result.message);
      } else {
        setUsernameError(null);
      }
    } catch (error) {
      console.error('Username validation error:', error);
      setUsernameError(null);
    } finally {
      setUsernameValidating(false);
    }
  }, 800),
  []
);

const validatePhoneDebounced = useCallback(
  debounce(async (phone) => {
    if (!phone || phone.length < 10) {
      setPhoneError(null);
      setPhoneValidating(false);
      return;
    }

    setPhoneValidating(true);
    
    try {
      const FirebaseService = (await import('../../services/FirebaseService')).default;
      const result = await FirebaseService.validatePhoneAvailability(phone);
      
      if (!result.available) {
        setPhoneError(result.message);
      } else {
        setPhoneError(null);
      }
    } catch (error) {
      console.error('Phone validation error:', error);
      setPhoneError(null);
    } finally {
      setPhoneValidating(false);
    }
  }, 800),
  []
);

// Input change handlers
const handleEmailChange = (email) => {
  setFormData(prev => ({ ...prev, email }));
  setEmailError(null); // Clear error immediately
  validateEmailDebounced(email);
};

const handleUsernameChange = (username) => {
  setFormData(prev => ({ ...prev, username }));
  setUsernameError(null); // Clear error immediately  
  validateUsernameDebounced(username);
};

const handlePhoneChange = (phone) => {
  setFormData(prev => ({ ...prev, phone }));
  setPhoneError(null); // Clear error immediately
  validatePhoneDebounced(phone);
};

    //clean existing duplicates
    useEffect(() => {
    cleanupExistingDuplicates();
  }, []);

  // Username generation arrays
  const adjectives = [
    'Swift', 'Bold', 'Bright', 'Quick', 'Strong', 'Smart', 'Fast', 'Cool', 'Epic', 'Pro',
    'Elite', 'Prime', 'Super', 'Mega', 'Ultra', 'Alpha', 'Beta', 'Dynamic', 'Stellar', 'Cosmic',
    'Lightning', 'Thunder', 'Blazing', 'Frozen', 'Golden', 'Silver', 'Diamond', 'Platinum', 'Turbo', 'Nitro',
    'Wild', 'Free', 'Pure', 'True', 'Real', 'Live', 'Active', 'Power', 'Force', 'Energy'
  ];
  
  const nouns = [
    'Tiger', 'Eagle', 'Wolf', 'Lion', 'Bear', 'Hawk', 'Fox', 'Shark', 'Panther', 'Falcon',
    'Runner', 'Player', 'Champion', 'Hero', 'Warrior', 'Knight', 'Master', 'Legend', 'Star', 'Ace',
    'Storm', 'Fire', 'Ice', 'Wind', 'Rock', 'Steel', 'Thunder', 'Lightning', 'Comet', 'Meteor',
    'Phoenix', 'Dragon', 'Ninja', 'Samurai', 'Gladiator', 'Titan', 'Giant', 'Beast', 'Spirit', 'Shadow'
  ];
  
  const securityQuestionOptions = [
  "What city were you born in?",  
  "What is your mother's maiden name?",
  "What was the name of your first pet?",
  "What is your favorite sports team?",
  "What was the name of your elementary school?",
  "What is your father's middle name?",
  "What was your childhood nickname?",
  "What is the name of your favorite teacher?",
  "What street did you grow up on?",
  "What is your favorite movie?",
  "What was the model of your first car?",
  "What is your favorite food?",
];

  //generateUniqueId
  const generateUniqueId = () => {
  const timestamp = Date.now();
  const random = Math.floor(Math.random() * 10000);
  return `${timestamp}-${random}`;
};

  const generateUsername = () => {
    const randomAdjective = adjectives[Math.floor(Math.random() * adjectives.length)];
    const randomNoun = nouns[Math.floor(Math.random() * nouns.length)];
    const randomNumber = Math.floor(Math.random() * 999) + 1;
    return `${randomAdjective}${randomNoun}${randomNumber}`;
  };

  const regenerateUsername = () => {
    const newUsername = generateUsername();
    setFormData(prev => ({ ...prev, username: newUsername }));
    setIsUsernameAutoGenerated(true);
    validateField('username', newUsername);
  };

  //Email, phone, and username check
  // Add these new validation functions
const checkEmailExists = async (email, excludeUserId = null) => {
  if (!email) return { allowed: true };
  
  try {
    const registeredUsersData = await AsyncStorage.getItem('registeredUsers');
    if (!registeredUsersData) return { allowed: true };
    
    const users = JSON.parse(registeredUsersData);
    const emailExists = users.some(user => 
      user.email.toLowerCase() === email.toLowerCase() && 
      user.id !== excludeUserId
    );
    
    return {
      allowed: !emailExists,
      message: emailExists ? VALIDATION_LIMITS.email.message : ''
    };
  } catch (error) {
    console.error('Error checking email:', error);
    return { allowed: true };
  }
};

const checkUsernameExists = async (username, excludeUserId = null) => {
  if (!username) return { allowed: true };
  
  try {
    const registeredUsersData = await AsyncStorage.getItem('registeredUsers');
    if (!registeredUsersData) return { allowed: true };
    
    const users = JSON.parse(registeredUsersData);
    const usernameExists = users.some(user => 
      user.username.toLowerCase() === username.toLowerCase() && 
      user.id !== excludeUserId
    );
    
    return {
      allowed: !usernameExists,
      message: usernameExists ? VALIDATION_LIMITS.username.message : ''
    };
  } catch (error) {
    console.error('Error checking username:', error);
    return { allowed: true };
  }
};

const checkPhoneNumberLimit = async (phoneNumber, excludeUserId = null) => {
  if (!phoneNumber) return { allowed: true }; // Phone is optional
  
  try {
    const registeredUsersData = await AsyncStorage.getItem('registeredUsers');
    if (!registeredUsersData) return { allowed: true };
    
    const users = JSON.parse(registeredUsersData);
    
    // Clean phone number for comparison (remove spaces, dashes, etc.)
    const cleanPhone = phoneNumber.replace(/[\s\-\(\)]/g, '');
    
    const phoneCount = users.filter(user => {
      if (!user.phone || user.id === excludeUserId) return false;
      const cleanUserPhone = user.phone.replace(/[\s\-\(\)]/g, '');
      return cleanUserPhone === cleanPhone;
    }).length;
    
    if (phoneCount >= VALIDATION_LIMITS.phone.maxAccounts) {
      return {
        allowed: false,
        message: VALIDATION_LIMITS.phone.message,
        currentCount: phoneCount
      };
    }
    
    return { allowed: true, currentCount: phoneCount };
  } catch (error) {
    console.error('Error checking phone limit:', error);
    return { allowed: true };
  }
};

// Enhanced progress calculation with field-level tracking
const getPersonalizedStepData = (stepIndex) => {
  const fullName = `${formData.firstName} ${formData.lastName}`.trim();
  const sport = formData.sport.trim();
  const userType = formData.userType;

  // Calculate step 0 progress based on filled fields
  const calculateStep0Progress = () => {
    const requiredFields = ['firstName', 'lastName', 'email', 'username'];
    const validRequiredFields = requiredFields.filter(field => {
      const value = formData[field];
      switch (field) {
        case 'firstName':
        case 'lastName':
          return value && isValidName(value);
        case 'email':
          return value && isValidEmail(value);
        case 'username':
          return value && isValidUsername(value);
        default:
          return !!value;
      }
    }).length;

    // Optional fields (phone, sport) can add small bonus
    const optionalBonus = (formData.phone && isValidPhone(formData.phone) ? 0.02 : 0) + 
                         (formData.sport ? 0.02 : 0);

    if (validRequiredFields === 0) return 0;
    if (validRequiredFields === requiredFields.length) return 0.33; // Complete
    
    // Partial progress: start at 5% for any interaction, then scale up
    return Math.min(0.05 + (validRequiredFields / requiredFields.length) * 0.25 + optionalBonus, 0.32);
  };

  // Check if step is completed
const isStepCompleted = (step) => {
  switch (step) {
    case 0: // NEW - Auth method selection
      return formData.authMethod !== null;
    case 1: // MOVED - Personal info
      return formData.firstName && formData.lastName && formData.email && formData.username && 
             isValidEmail(formData.email) && isValidUsername(formData.username) && 
             isValidName(formData.firstName) && isValidName(formData.lastName);
    case 2: // MOVED - Role selection
      return formData.userType && (formData.userType !== 'OTHER' || formData.customRole.trim());
    case 3: // MOVED - Security questions
      return formData.securityQuestion && formData.securityAnswer.trim().length >= 2;
    case 4: // MOVED - Password
      return formData.password && formData.confirmPassword && 
             isValidPassword(formData.password) && 
             isValidConfirmPassword(formData.password, formData.confirmPassword);
    default:
      return false;
  }
};

  // Generate role-based description
  const getRoleDescription = () => {
    if (userType === 'OTHER') {
      return formData.customRole.trim() || 'Other';
    }
    
    if (sport && (userType === USER_TYPES.PLAYER || userType === USER_TYPES.COACH || userType === USER_TYPES.TRAINER)) {
      switch (userType) {
        case USER_TYPES.PLAYER:
          return `${sport} Player`;
        case USER_TYPES.COACH:
          return `${sport} Coach`;
        case USER_TYPES.TRAINER:
          return `${sport} Trainer`;
        default:
          return `${sport} Athlete`;
      }
    } else {
      switch (userType) {
        case USER_TYPES.PLAYER:
          return 'Athlete';
        case USER_TYPES.COACH:
          return 'Coach';
        case USER_TYPES.TRAINER:
          return 'Personal Trainer';
        case USER_TYPES.PARENT:
          return 'Parent';
        default:
          return 'Other';
      }
    }
  };


    const steps = [
  {
    title: "Get Started",
    subtitle: "Choose how to create your account",
    icon: "login",
    progress: isStepCompleted(0) ? 0.20 : (currentStep > 0 ? 0.20 : 0),
    completed: isStepCompleted(0)
  },
  {
    title: "Personal Info",
    subtitle: "Tell us about yourself",
    icon: "person",
    progress: calculateStep0Progress(),
    completed: isStepCompleted(1),
    showUserImage: formData.firstName || formData.lastName
  },
  {
    title: fullName || "Account Setup",
    subtitle: "Choose your role",
    icon: "settings",
    progress: isStepCompleted(2) ? 0.60 : (currentStep > 2 ? 0.60 : 0.40),
    showUserImage: true,
    completed: isStepCompleted(2)
  },
  {
    title: fullName || "Security Setup",
    subtitle: getRoleDescription() + " â€¢ Account recovery",
    icon: "security",
    progress: isStepCompleted(3) ? 0.80 : 0.60,
    showUserImage: true,
    completed: isStepCompleted(3)
  },
  {
    title: fullName || "Password",
    subtitle: getRoleDescription() + " â€¢ Secure your account",
    icon: "lock",
    progress: isStepCompleted(4) ? 1.0 : 0.80,
    showUserImage: true,
    completed: isStepCompleted(4)
  }
];

  return steps[stepIndex];
};

// Account creatin security and integrity
const VALIDATION_LIMITS = {
  email: {
    maxAccounts: 1,
    message: 'This email is already registered. Please use a different email or sign in.'
  },
  username: {
    maxAccounts: 1,
    message: 'This username is already taken. Please choose a different username.'
  },
  phone: {
    maxAccounts: 4,
    message: 'This phone number is associated with too many accounts. Please use a different number.'
  }
};

  // Real-time validation functions
  const isValidEmail = (email) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  };

  const isValidPhone = (phone) => {
    if (!phone) return true; // Phone is optional
    // Updated regex to allow numbers starting with 0 (including 07, 01, 02, etc.)
    const phoneRegex = /^[\+]?[0-9][\d]{6,14}$/;
    return phoneRegex.test(phone.replace(/[\s\-\(\)]/g, ''));
  };

  //for security question
  const isValidSecurityAnswer = (answer) => {
  return answer.trim().length >= 2;
};

  //password icon helper
  const getPasswordStrengthIcon = () => {
  const password = formData.password;
  if (!password) return "help-outline";
  
  if (password.length < 6) return "error-outline";
  if (password.length >= 6 && password.length < 8) return "warning";
  if (password.length >= 8) {
    // Check for strong password (has numbers, letters, special chars)
    const hasNumbers = /\d/.test(password);
    const hasLetters = /[a-zA-Z]/.test(password);
    const hasSpecialChars = /[!@#$%^&*(),.?":{}|<>]/.test(password);
    
    if (hasNumbers && hasLetters && hasSpecialChars) return "verified";
    if (hasNumbers && hasLetters) return "check-circle";
    return "info";
  }
  
    return "help-outline";
  };

  const getPasswordStrengthColor = () => {
    const password = formData.password;
    if (!password) return COLORS.textSecondary;
    
    if (password.length < 6) return "#EF4444"; // Red
    if (password.length >= 6 && password.length < 8) return "#F59E0B"; // Orange
    if (password.length >= 8) {
      const hasNumbers = /\d/.test(password);
      const hasLetters = /[a-zA-Z]/.test(password);
      const hasSpecialChars = /[!@#$%^&*(),.?":{}|<>]/.test(password);
      
      if (hasNumbers && hasLetters && hasSpecialChars) return "#10B981"; // Green - Very Strong
      if (hasNumbers && hasLetters) return "#059669"; // Dark Green - Strong
      return "#3B82F6"; // Blue - Good
    }
    
    return COLORS.textSecondary;
  };

  const getPasswordMatchIcon = () => {
    if (!formData.confirmPassword) return "help-outline";
    if (!formData.password) return "help-outline";
    
    if (formData.password === formData.confirmPassword) {
      return "check-circle";
    } else {
      return "cancel";
    }
  };

  const getPasswordMatchColor = () => {
    if (!formData.confirmPassword || !formData.password) return COLORS.textSecondary;
    
    if (formData.password === formData.confirmPassword) {
      return "#10B981"; // Green
    } else {
      return "#EF4444"; // Red
    }
  };

  const isValidName = (name) => {
    return name.trim().length >= 2;
  };

  const isValidUsername = (username) => {
    return username.trim().length >= 3;
  };

  const isValidPassword = (password) => {
    return password.length >= 6;
  };

  const isValidConfirmPassword = (password, confirmPassword) => {
    return confirmPassword && password === confirmPassword;
  };

const validateField = async (field, value) => {
  let isValid = false;
  let errorMessage = '';

  switch (field) {
    case 'firstName':
      isValid = isValidName(value);
      if (!isValid && value) errorMessage = 'First name must be at least 2 characters';
      if (!value) errorMessage = 'First name is required';
      break;
      
    case 'lastName':
      isValid = isValidName(value);
      if (!isValid && value) errorMessage = 'Last name must be at least 2 characters';
      if (!value) errorMessage = 'Last name is required';
      break;
      
    case 'email':
      // First check format
      const emailFormatValid = isValidEmail(value);
      if (!value) {
        errorMessage = 'Email is required';
        isValid = false;
      } else if (!emailFormatValid) {
        errorMessage = 'Please enter a valid email address';
        isValid = false;
      } else {
        // Check for duplicates
        const emailCheck = await checkEmailExists(value);
        if (!emailCheck.allowed) {
          errorMessage = emailCheck.message;
          isValid = false;
        } else {
          isValid = true;
        }
      }
      break;
      
    case 'username':
      // First check format
      const usernameFormatValid = isValidUsername(value);
      if (!value) {
        errorMessage = 'Username is required';
        isValid = false;
      } else if (!usernameFormatValid) {
        errorMessage = 'Username must be at least 3 characters';
        isValid = false;
      } else {
        // Check for duplicates
        const usernameCheck = await checkUsernameExists(value);
        if (!usernameCheck.allowed) {
          errorMessage = usernameCheck.message;
          isValid = false;
        } else {
          isValid = true;
        }
      }
      break;
      
    case 'phone':
      // First check format
      const phoneFormatValid = isValidPhone(value);
      if (value && !phoneFormatValid) {
        errorMessage = 'Please enter a valid phone number';
        isValid = false;
      } else if (value) {
        // Check for limits
        const phoneCheck = await checkPhoneNumberLimit(value);
        if (!phoneCheck.allowed) {
          errorMessage = phoneCheck.message;
          isValid = false;
        } else {
          isValid = true;
        }
      } else {
        isValid = true; // Phone is optional
      }
      break;
      
    case 'password':
      isValid = isValidPassword(value);
      if (!isValid && value) errorMessage = 'Password must be at least 6 characters';
      if (!value) errorMessage = 'Password is required';
      break;
      
    case 'confirmPassword':
      isValid = isValidConfirmPassword(formData.password, value);
      if (!isValid && value) errorMessage = 'Passwords do not match';
      if (!value) errorMessage = 'Please confirm your password';
      break;
      
    case 'sport':
      isValid = true; // Sport is optional
      break;


    case 'securityQuestion':
      isValid = !!value;
      if (!value) errorMessage = 'Please select or enter a security question';
      break;
      
    case 'securityAnswer':
      isValid = isValidSecurityAnswer(value);
      if (!isValid && value) errorMessage = 'Answer must be at least 2 characters';
      if (!value) errorMessage = 'Security answer is required';
      break;
      
    default:
      break;
  }

  // Update validation state
  setValidFields(prev => ({ ...prev, [field]: isValid && value }));
  setErrors(prev => ({ ...prev, [field]: errorMessage }));

  return isValid;
};

const handleInputChange = async (field, value) => {
  setFormData(prev => ({ ...prev, [field]: value }));
  
  // Show validation loading for async fields
  if (['email', 'username', 'phone'].includes(field)) {
    setValidationLoading(prev => ({ ...prev, [field]: true }));
  }
  
  // Auto-generate username logic...
  if (field === 'email' && value && !formData.username) {
    const generatedUsername = generateUsername();
    setFormData(prev => ({ ...prev, username: generatedUsername }));
    setIsUsernameAutoGenerated(true);
    await validateField('username', generatedUsername);
  }
  
  // Real-time validation
  await validateField(field, value);
  
  // Hide validation loading
  if (['email', 'username', 'phone'].includes(field)) {
    setValidationLoading(prev => ({ ...prev, [field]: false }));
  }
  
  // Handle username manual editing
  if (field === 'username') {
    setIsUsernameAutoGenerated(false);
  }
};

const handleAuthMethodSelect = (methodData) => {
  const method = typeof methodData === 'string' ? methodData : methodData.id;
  const userData = methodData.userData || {};
  
  // Update form data
  setFormData(prev => ({
    ...prev,
    authMethod: method,
    ...userData
  }));
  
  // Auto-advance to next step
  if (method === 'google' && userData.email) {
    // For Google, show success message and advance
    setTimeout(() => {
      animateToStep(currentStep + 1);
    }, 1000);
  } else {
    // For email and phone, advance immediately
    setTimeout(() => {
      animateToStep(currentStep + 1);
    }, 300);
  }
};

const validateStep = async (step) => {
  const newErrors = {};
  
  switch (step) {
    case 0:
      if (!formData.authMethod) {
        newErrors.authMethod = 'Please select an authentication method';
      }
      break;
    case 1:
      const step1Fields = [
        { field: 'firstName', value: formData.firstName },
        { field: 'lastName', value: formData.lastName },
        { field: 'email', value: formData.email },
        { field: 'username', value: formData.username },
        { field: 'phone', value: formData.phone }
      ];
      
      for (const { field, value } of step1Fields) {
        const isValid = await validateField(field, value);
        if (!isValid && errors[field]) {
          newErrors[field] = errors[field];
        }
      }
      break;
    case 2:
      if (formData.userType === 'OTHER' && !formData.customRole.trim()) {
        newErrors.customRole = 'Please specify your role';
      }
      break;
    case 3:
      if (!formData.securityQuestion) {
        newErrors.securityQuestion = 'Please select or enter a security question';
      }
      if (!formData.securityAnswer.trim()) {
        newErrors.securityAnswer = 'Security answer is required';
      } else if (formData.securityAnswer.trim().length < 2) {
        newErrors.securityAnswer = 'Answer must be at least 2 characters';
      }
      break;
    case 4:
      // Password validation - required for all auth methods
      if (!formData.password) {
        newErrors.password = formData.authMethod === 'google' 
          ? 'Password is required for email login access'
          : 'Password is required';
      } else if (formData.password.length < 6) {
        newErrors.password = 'Password must be at least 6 characters';
      }
      if (!formData.confirmPassword) {
        newErrors.confirmPassword = 'Please confirm your password';
      } else if (formData.password !== formData.confirmPassword) {
        newErrors.confirmPassword = 'Passwords do not match';
      }
      break;
  }
  
  setErrors(prevErrors => ({ ...prevErrors, ...newErrors }));
  return Object.keys(newErrors).length === 0;
};

const nextStep = async () => {
  const isStepValid = await validateStep(currentStep);
  
  if (isStepValid) {
    if (currentStep < 4) {
      animateToStep(currentStep + 1);
    } else {
      handleRegister();
    }
  } else {
    Alert.alert(
      'Please fix errors', 
      'Please correct the highlighted fields before continuing'
    );
  }
};

  const prevStep = () => {
    if (currentStep > 0) {
      animateToStep(currentStep - 1);
    }
  };

  const animateToStep = (stepIndex) => {
    Animated.timing(slideAnim, {
      toValue: -stepIndex * screenWidth,
      duration: 300,
      useNativeDriver: true,
    }).start();
    setCurrentStep(stepIndex);
  };

  const handleImageUpload = () => {
    setShowImageModal(true);
  };

  const selectImageFromGallery = () => {
    const options = {
      mediaType: 'photo',
      includeBase64: false,
      maxHeight: 2000,
      maxWidth: 2000,
    };

    launchImageLibrary(options, (response) => {
      if (response.didCancel || response.error) {
        console.log('ImagePicker cancelled or error');
      } else if (response.assets && response.assets[0]) {
        setFormData(prev => ({
          ...prev,
          profileImage: response.assets[0].uri
        }));
      }
    });
    setShowImageModal(false);
  };

  const selectImageFromCamera = () => {
    const options = {
      mediaType: 'photo',
      includeBase64: false,
      maxHeight: 2000,
      maxWidth: 2000,
    };

    launchCamera(options, (response) => {
      if (response.didCancel || response.error) {
        console.log('Camera cancelled or error');
      } else if (response.assets && response.assets[0]) {
        setFormData(prev => ({
          ...prev,
          profileImage: response.assets[0].uri
        }));
      }
    });
    setShowImageModal(false);
  };

// Replace your handleRegister function in MultiStepRegisterScreen with this fixed version:

const handleRegister = async () => {
  if (!await validateStep(currentStep)) {
    return;
  }

  dispatch(loginStart());
  
  try {
    // Import FirebaseService
    const FirebaseService = (await import('../../services/FirebaseService')).default;
    
    // Check for duplicates FIRST using the new prevention method
    console.log('ðŸ” Checking for duplicate user...');
    const duplicateCheck = await FirebaseService.preventDuplicateUser({
      email: formData.email.trim().toLowerCase()
    });
    
    if (duplicateCheck.exists) {
      dispatch(loginFailure('User already exists'));
      Alert.alert(
        'Account Already Exists', 
        `An account with this email already exists. Please sign in instead.`,
        [
          { text: 'Cancel' },
          { 
            text: 'Go to Sign In', 
            onPress: () => navigation.navigate('Login')
          }
        ]
      );
      return;
    }

    // Additional validation before registration
    console.log('ðŸ” Starting pre-registration validation...');
    
    try {
      // Validate email availability (double-check)
      const emailCheck = await FirebaseService.validateEmailAvailability(formData.email);
      if (!emailCheck.available) {
        Alert.alert('Email Already Exists', emailCheck.message);
        return;
      }
      
      // Validate username availability
      const usernameCheck = await FirebaseService.validateUsernameAvailability(formData.username);
      if (!usernameCheck.available) {
        Alert.alert('Username Taken', usernameCheck.message);
        return;
      }
      
      // Validate phone availability (if provided)
      if (formData.phone && formData.phone.trim()) {
        const phoneCheck = await FirebaseService.validatePhoneAvailability(formData.phone);
        if (!phoneCheck.available) {
          Alert.alert('Phone Number Limit', phoneCheck.message);
          return;
        }
      }
      
      console.log('âœ… Pre-registration validation passed');
    } catch (validationError) {
      console.warn('âš ï¸ Pre-registration validation failed:', validationError.message);
      // Continue with registration - validation failure shouldn't block registration
    }

    // Clean up the data before storing
    const cleanData = {
      ...formData,
      id: generateUniqueId(),
      createdAt: new Date().toISOString(),
      email: formData.email.trim().toLowerCase(),
      firstName: formData.firstName.trim(),
      lastName: formData.lastName.trim(),
      username: formData.username.trim(),
      phone: formData.phone.trim(),
      sport: formData.sport.trim(),
      authMethod: formData.authMethod,
      password: formData.password,
      hasLocalPassword: true,
    };

    // For Google users, also include OAuth data
    if (formData.authMethod === 'google') {
      cleanData.googleId = formData.googleId;
      cleanData.idToken = formData.idToken;
      cleanData.accessToken = formData.accessToken;
      cleanData.profileImage = formData.profileImage;
    }

    delete cleanData.confirmPassword;

    // Final local duplicate check (backup safety check)
    const existingUsersJson = await AsyncStorage.getItem('registeredUsers');
    let existingUsers = existingUsersJson ? JSON.parse(existingUsersJson) : [];
    
    const duplicate = existingUsers.find(user => 
      user.email.toLowerCase() === cleanData.email.toLowerCase() ||
      user.username.toLowerCase() === cleanData.username.toLowerCase()
    );
    
    if (duplicate) {
      dispatch(loginFailure('User already exists'));
      Alert.alert(
        'Account Already Exists', 
        `An account with this ${duplicate.email.toLowerCase() === cleanData.email.toLowerCase() ? 'email' : 'username'} already exists.`
      );
      return;
    }

    // Store locally first (offline-first)
    const updatedUsers = [...existingUsers, cleanData];
    await AsyncStorage.multiSet([
      ['registeredUsers', JSON.stringify(updatedUsers)],
      ['user_data', JSON.stringify({ ...cleanData, password: undefined })],
      ['authenticatedUser', JSON.stringify({ ...cleanData, password: undefined })],
      ['autoLoginEnabled', 'true']
    ]);

    console.log('âœ… Local registration successful for:', cleanData.email);

    // Attempt immediate Firebase sync with better error handling
    let syncResult = { success: false, error: 'Not attempted' };
    
    try {
      const isOnline = await FirebaseService.checkInternetConnection();
      
      if (isOnline) {
        console.log('ðŸ”„ Attempting immediate Firebase sync...');
        syncResult = await FirebaseService.registerUser(cleanData);
        
        if (syncResult.success) {
          console.log('âœ… User immediately synced to Firebase');
          
          // Update local storage with Firebase data
          const updatedUserWithFirebase = {
            ...cleanData,
            firebaseUid: syncResult.userData?.firebaseUid || syncResult.uid,
            syncedToServer: true,
            lastSyncAt: new Date().toISOString(),
          };
          
          const finalUsers = updatedUsers.map(user => 
            user.email.toLowerCase() === cleanData.email.toLowerCase() 
              ? updatedUserWithFirebase 
              : user
          );
          
          await AsyncStorage.setItem('registeredUsers', JSON.stringify(finalUsers));
          
          dispatch(loginSuccess({ ...updatedUserWithFirebase, password: undefined }));
          
          Alert.alert(
            'Welcome to Acceilla!', 
            `Your account has been created and synced successfully, ${cleanData.firstName}!`,
            [{ text: 'Get Started', onPress: () => navigation.replace('Main') }]
          );
          return;
        } else {
          console.warn('âš ï¸ Firebase sync failed:', syncResult.error);
        }
      }
    } catch (error) {
      console.warn('âš ï¸ Immediate sync failed:', error.message);
      syncResult = { success: false, error: error.message };
    }
    
    // Handle offline/failed sync
    dispatch(loginSuccess({ ...cleanData, password: undefined }));
    
    const isOffline = syncResult.error && (
      syncResult.error.includes('offline') || 
      syncResult.error.includes('network') || 
      syncResult.error.includes('timeout')
    );
    
    Alert.alert(
      'Welcome to Acceilla!', 
      isOffline 
        ? `Your account has been created offline, ${cleanData.firstName}! It will sync when you're connected to the internet.`
        : `Your account has been created, ${cleanData.firstName}! It will sync to the cloud when you're connected.`,
      [{ text: 'Get Started', onPress: () => navigation.replace('Main') }]
    );
    
  } catch (error) {
    console.error('âŒ Registration error:', error);
    dispatch(loginFailure(error.message || 'Registration failed'));
    
    let errorMessage = 'Something went wrong during registration. Please try again.';
    
    if (error.message.includes('already exists')) {
      errorMessage = error.message;
    } else if (error.message.includes('network')) {
      errorMessage = 'Network error. Please check your connection and try again.';
    }
    
    Alert.alert('Registration Failed', errorMessage);
  }
};



    // 3. ADD CLEANUP FUNCTION to remove duplicates from existing data:
    const cleanupDuplicateUsers = async () => {
      try {
        const registeredUsersJson = await AsyncStorage.getItem('registeredUsers');
        if (registeredUsersJson) {
          const users = JSON.parse(registeredUsersJson);
          
          // Remove duplicates based on email (keep the first occurrence)
          const uniqueUsers = users.filter((user, index, array) => 
            array.findIndex(u => u.email.toLowerCase() === user.email.toLowerCase()) === index
          );
          
          if (uniqueUsers.length !== users.length) {
            console.log(`Removed ${users.length - uniqueUsers.length} duplicate users`);
            await AsyncStorage.setItem('registeredUsers', JSON.stringify(uniqueUsers));
          }
        }
      } catch (error) {
        console.error('Error cleaning up duplicate users:', error);
      }
    };

  const getInitials = () => {
    const first = formData.firstName?.charAt(0) || '';
    const last = formData.lastName?.charAt(0) || '';
    return (first + last).toUpperCase();
  };

  const userTypeOptions = [
    { value: USER_TYPES.PLAYERS, label: 'Player', description: 'Follow training programs', icon: 'sports' },
    { value: USER_TYPES.ATHLETE, label: 'Athlete', description: 'Follow training programs', icon: 'sports' },
    { value: USER_TYPES.COACH, label: 'Coach', description: 'Create and manage programs', icon: 'sports-handball' },
    { value: USER_TYPES.TRAINER, label: 'Personal Trainer', description: 'One-on-one training', icon: 'fitness-center' },
    { value: USER_TYPES.TRAINEE, label: 'Trainee', description: 'One-on-one training', icon: 'fitness-center' },
    { value: USER_TYPES.PARENT, label: 'Parent', description: 'Track child\'s progress', icon: 'family-restroom' },
    { value: USER_TYPES.CHILD, label: 'Child Profile', description: 'Add Child Profile', icon: 'family-restroom' },
    { value: 'OTHER', label: 'Other', description: 'Specify your role below', icon: 'more-horiz' },
  ];

  // Clean validation styling that preserves original layout
  const getInputTheme = (field) => {
    const hasError = !!errors[field];
    const isValid = validFields[field];
    
    return {
      colors: {
        primary: isValid ? '#10B981' : hasError ? '#EF4444' : COLORS.primary,
        outline: isValid ? '#10B981' : hasError ? '#EF4444' : COLORS.border,
        onSurfaceVariant: COLORS.textSecondary,
        onSurface: COLORS.inputText 
      }
    };
  };

  const renderStepHeader = () => {
    const stepData = getPersonalizedStepData(currentStep);
    const hasUserData = formData.firstName || formData.lastName;
    
    return (
      <View style={styles.stepHeader}>
        <TouchableOpacity 
          onPress={currentStep === 1 ? handleImageUpload : undefined} 
          style={styles.stepIconContainer}
          activeOpacity={currentStep === 1 ? 0.7 : 1}>
          {stepData.showUserImage && formData.profileImage ? (
            <Avatar.Image 
              size={56} 
              source={{ uri: formData.profileImage }}
              style={styles.stepHeaderImage}
            />
          ) : stepData.showUserImage && hasUserData ? (
            <Avatar.Text 
              size={56} 
              label={getInitials()} 
              style={[styles.stepHeaderImage, { backgroundColor: COLORS.primary }]}
            />
          ) : currentStep === 1 && formData.profileImage ? (
            <Avatar.Image 
              size={56} 
              source={{ uri: formData.profileImage }}
              style={styles.stepHeaderImage}
            />
          ) : currentStep === 1 && hasUserData ? (
            <Avatar.Text 
              size={56} 
              label={getInitials()} 
              style={[styles.stepHeaderImage, { backgroundColor: COLORS.primary }]}
            />
          ) : currentStep === 1 ? (
            <Avatar.Text 
              size={56} 
              label="+" 
              style={[styles.stepHeaderImage, { backgroundColor: COLORS.primary }]}
            />
          ) : (
            <Icon name={stepData.icon} size={32} color={COLORS.primary} />
          )}
          {currentStep === 1 && (
            <View style={styles.stepHeaderCameraIcon}>
              <Icon name="camera-alt" size={16} color={COLORS.surface} />
            </View>
          )}
        </TouchableOpacity>
        <Text style={styles.stepTitle}>{stepData.title}</Text>
        <Text style={styles.stepSubtitle}>{stepData.subtitle}</Text>
        {currentStep === 1 && (
        <Button 
          mode="outlined" 
          onPress={handleImageUpload}
          style={styles.stepHeaderUploadButton}
          icon="image">
          Upload Profile Image
        </Button>

      )}
      </View>
    );
  };

  const renderStep = () => {
  switch (currentStep) {
  case 0:
    return null;
      case 1:
        return (
          <View style={styles.stepContainer}>
            <ScrollView 
              style={styles.stepScrollContainer} 
              contentContainerStyle={styles.stepScrollContent}
              showsVerticalScrollIndicator={false}>
              
              <View style={styles.formSection}>
                <View style={styles.nameRow}>
                  <TextInput
                    label="First Name *"
                    value={formData.firstName}
                    onChangeText={(value) => handleInputChange('firstName', value)}
                    mode="outlined"
                    style={[styles.input, styles.halfInput]}
                    error={!!errors.firstName}
                    theme={getInputTheme('firstName')}
                    right={validFields.firstName && (
                      <TextInput.Icon 
                        icon="check-circle" 
                        iconColor="#10B981"
                        size={20}
                      />
                    )}
                  />
                  <TextInput
                    label="Last Name *"
                    value={formData.lastName}
                    onChangeText={(value) => handleInputChange('lastName', value)}
                    mode="outlined"
                    style={[styles.input, styles.halfInput]}
                    error={!!errors.lastName}
                    theme={getInputTheme('lastName')}
                    right={validFields.lastName && (
                      <TextInput.Icon 
                        icon="check-circle" 
                        iconColor="#10B981"
                        size={20}
                      />
                    )}
                  />
                </View>
                {(errors.firstName || errors.lastName) && (
                  <View style={styles.errorRow}>
                    {errors.firstName && <HelperText type="error" style={styles.halfError}>{errors.firstName}</HelperText>}
                    {errors.lastName && <HelperText type="error" style={styles.halfError}>{errors.lastName}</HelperText>}
                  </View>
                )}

                <TextInput
                  label="Email Address *"
                  value={formData.email}
                  onChangeText={(value) => handleInputChange('email', value)}
                  mode="outlined"
                  keyboardType="email-address"
                  autoCapitalize="none"
                  autoComplete="email"
                  style={styles.input}
                  placeholder="example@gmail.com"
                  right={
                    validationLoading.email ? (
                      <TextInput.Icon icon="loading" iconColor={COLORS.primary} />
                    ) : validFields.email ? (
                      <TextInput.Icon icon="check-circle" iconColor="#10B981" size={20} />
                    ) : undefined
                  }
                  error={!!errors.email}
                  theme={getInputTheme('email')}
                />
                {errors.email && <HelperText type="error" style={styles.errorText}>{errors.email}</HelperText>}

                <TextInput
                  label="Username *"
                  value={formData.username}
                  onChangeText={(value) => handleInputChange('username', value)}
                  mode="outlined"
                  autoCapitalize="none"
                  style={styles.input}
                  right={validFields.username && (
                    <TextInput.Icon 
                      icon="check-circle" 
                      iconColor="#10B981"
                      size={20}
                    />
                  )}
                  error={!!errors.username}
                  placeholder="Auto-generated (you can edit)"
                  theme={getInputTheme('username')}
                />
                {errors.username && <HelperText type="error" style={styles.errorText}>{errors.username}</HelperText>}
                
                {isUsernameAutoGenerated && (
                  <View style={styles.usernameControls}>
                    <Chip
                      style={styles.autoGeneratedBadge}
                      textStyle={styles.autoGeneratedBadgeText}>
                      Auto-generated
                    </Chip>
                    <Button
                      mode="text"
                      onPress={regenerateUsername}
                      style={styles.regenerateButton}
                      labelStyle={styles.regenerateButtonLabel}
                      icon="refresh">
                      Regenerate
                    </Button>
                  </View>
                )}

                <TextInput
                  label="Phone Number"
                  value={formData.phone}
                  onChangeText={(value) => handleInputChange('phone', value)}
                  mode="outlined"
                  keyboardType="phone-pad"
                  style={styles.input}
                  placeholder="0123456789 or +254712345678"
                  right={validFields.phone && (
                    <TextInput.Icon 
                      icon="check-circle" 
                      iconColor="#10B981"
                      size={20}
                    />
                  )}
                  error={!!errors.phone}
                  theme={getInputTheme('phone')}
                />
                {errors.phone && <HelperText type="error" style={styles.errorText}>{errors.phone}</HelperText>}

                <TextInput
                  label="Sport/Activity"
                  value={formData.sport}
                  onChangeText={(value) => handleInputChange('sport', value)}
                  mode="outlined"
                  style={styles.input}
                  right={validFields.sport && (
                    <TextInput.Icon 
                      icon="check-circle" 
                      iconColor="#10B981"
                      size={20}
                    />
                  )}
                  placeholder="e.g., Football, Basketball, Running"
                  theme={getInputTheme('sport')}
                />
              </View>
            </ScrollView>
          </View>
        );

      case 2:
        return (
          <View style={styles.stepContainer}>
            <ScrollView 
              style={styles.stepScrollContainer} 
              contentContainerStyle={styles.stepScrollContentCompact}
              showsVerticalScrollIndicator={false}>
              
              <View style={styles.formSection}>
                <Text style={styles.sectionTitleCompact}>I am a:</Text>
                <RadioButton.Group
                  onValueChange={(value) => handleInputChange('userType', value)}
                  value={formData.userType}>
                  {userTypeOptions.map((option) => (
                    <TouchableOpacity 
                      key={option.value} 
                      style={[
                        styles.userTypeOptionCompact,
                        formData.userType === option.value && styles.userTypeOptionSelected
                      ]}
                      onPress={() => handleInputChange('userType', option.value)}>
                      <View style={styles.userTypeIconContainerCompact}>
                        <Icon 
                          name={option.icon} 
                          size={18} 
                          color={formData.userType === option.value ? '#3B82F6' : '#64748B'} 
                        />
                      </View>
                      <View style={styles.userTypeTextContainer}>
                        <Text style={[
                          styles.userTypeLabelCompact,
                          formData.userType === option.value && styles.userTypeLabelSelected
                        ]}>
                          {option.label}
                        </Text>
                        <Text style={styles.userTypeDescriptionCompact}>{option.description}</Text>
                      </View>
                      <RadioButton value={option.value} color="#3B82F6" />
                    </TouchableOpacity>
                  ))}
                </RadioButton.Group>

                {formData.userType === 'OTHER' && (
                  <View style={styles.customRoleContainer}>
                    <TextInput
                      label="Specify your role *"
                      value={formData.customRole}
                      onChangeText={(value) => handleInputChange('customRole', value)}
                      mode="outlined"
                      style={styles.input}
                      placeholder="e.g., Football Academy Owner, Sports Enthusiast, Former Athlete"
                      right={validFields.customRole && (
                        <TextInput.Icon 
                          icon="check-circle" 
                          iconColor="#10B981"
                          size={20}
                        />
                      )}
                      error={!!errors.customRole}
                      theme={getInputTheme('customRole')}
                    />
                    {errors.customRole && <HelperText type="error" style={styles.errorText}>{errors.customRole}</HelperText>}
                  </View>
                )}
              </View>
            </ScrollView>
          </View>
        );

        case 3:
  return (
    <View style={styles.stepContainer}>
      <ScrollView 
        style={styles.stepScrollContainer} 
        contentContainerStyle={styles.stepScrollContent}
        showsVerticalScrollIndicator={false}>
        
        <View style={styles.formSection}>
          <Text style={styles.sectionTitle}>Account Recovery</Text>
          <Text style={styles.sectionSubtitle}>
            Set up a security question to help recover your account if you forget your password.
          </Text>

          {/* Security Question Dropdown/Input */}
          <TextInput
            label="Security Question *"
            value={formData.securityQuestion}
            onChangeText={(value) => handleInputChange('securityQuestion', value)}
            mode="outlined"
            style={styles.input}
            placeholder="Select a question or write your own"
            right={
              <TextInput.Icon 
                icon="chevron-down" 
                onPress={() => setShowSecurityQuestionModal(true)}
              />
            }
            onFocus={() => setSecurityQuestionFocused(true)}
            onBlur={() => setSecurityQuestionFocused(false)}
            error={!!errors.securityQuestion}
            theme={getInputTheme('securityQuestion')}
          />
          {errors.securityQuestion && (
            <HelperText type="error" style={styles.errorText}>
              {errors.securityQuestion}
            </HelperText>
          )}

          {/* Quick Select Buttons */}
          <View style={styles.quickSelectContainer}>
            <Text style={styles.quickSelectTitle}>Popular Questions:</Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.quickSelectScroll}>
              {securityQuestionOptions.slice(0, 4).map((question, index) => (
                <Chip
                  key={index}
                  mode={formData.securityQuestion === question ? "flat" : "outlined"}
                  onPress={() => handleInputChange('securityQuestion', question)}
                  style={[
                    styles.quickSelectChip,
                    formData.securityQuestion === question && styles.quickSelectChipSelected
                  ]}
                  textStyle={styles.quickSelectChipText}>
                  {question.replace('?', '').substring(0, 25)}...
                </Chip>
              ))}
            </ScrollView>
          </View>

          {/* Security Answer */}
          <TextInput
            label="Your Answer *"
            value={formData.securityAnswer}
            onChangeText={(value) => handleInputChange('securityAnswer', value)}
            mode="outlined"
            autoCapitalize="words"
            style={styles.input}
            placeholder="Enter your answer (remember it well!)"
            right={validFields.securityAnswer && (
              <TextInput.Icon 
                icon="check-circle" 
                iconColor="#10B981"
                size={20}
              />
            )}
            onFocus={() => setSecurityAnswerFocused(true)}
            onBlur={() => setSecurityAnswerFocused(false)}
            error={!!errors.securityAnswer}
            theme={getInputTheme('securityAnswer')}
          />
          {errors.securityAnswer && (
            <HelperText type="error" style={styles.errorText}>
              {errors.securityAnswer}
            </HelperText>
          )}

          {/* Security Tips */}
          <View style={styles.securityTipsContainer}>
            <View style={styles.securityTip}>
              <Icon name="info" size={16} color="#3B82F6" />
              <Text style={styles.securityTipText}>
                Choose a question you'll remember the answer to years from now
              </Text>
            </View>
            <View style={styles.securityTip}>
              <Icon name="warning" size={16} color="#F59E0B" />
              <Text style={styles.securityTipText}>
                Don't share your security answer with anyone
              </Text>
            </View>
          </View>
        </View>
      </ScrollView>
    </View>
  );

      case 4:
        return (
          <View style={styles.stepContainer}>
            <ScrollView 
              style={styles.stepScrollContainer} 
              contentContainerStyle={styles.stepScrollContent}
              showsVerticalScrollIndicator={false}>
              
              <View style={styles.formSection}>
      <TextInput
        label="Password *"
        value={formData.password}
        onChangeText={(value) => handleInputChange('password', value)}
        mode="outlined"
        secureTextEntry={!showPassword}
        autoComplete="password-new"
        style={styles.input}
        right={
          <TextInput.Icon
            icon={showPassword ? "eye-off" : "eye"}
            onPress={() => setShowPassword(!showPassword)}
            iconColor={COLORS.primary}
          />
        }
        onFocus={() => setPasswordFocused(true)}
        onBlur={() => setPasswordFocused(false)}
        error={!!errors.password}
        theme={getInputTheme('password')}
      />
      {errors.password && <HelperText type="error" style={styles.errorText}>{errors.password}</HelperText>}

      <TextInput
        label="Confirm Password *"
        value={formData.confirmPassword}
        onChangeText={(value) => handleInputChange('confirmPassword', value)}
        mode="outlined"
        secureTextEntry={!showConfirmPassword}
        style={styles.input}
        left={
          // Only show icon if confirm password field is not focused AND has content
          formData.confirmPassword && !confirmPasswordFocused ? (
            <TextInput.Icon 
              icon={getPasswordMatchIcon()} 
              iconColor={getPasswordMatchColor()}
            />
          ) : undefined
        }
        right={
          <TextInput.Icon 
            icon={showConfirmPassword ? "eye-off" : "eye"} 
            onPress={() => setShowConfirmPassword(!showConfirmPassword)}
            iconColor={COLORS.primary}
          />
        }
        onFocus={() => setConfirmPasswordFocused(true)}
        onBlur={() => setConfirmPasswordFocused(false)}
        error={!!errors.confirmPassword}
        theme={getInputTheme('confirmPassword')}
      />
      {errors.confirmPassword && <HelperText type="error" style={styles.errorText}>{errors.confirmPassword}</HelperText>}

      <View style={styles.passwordStrength}>
        <Text style={styles.passwordStrengthTitle}>Password Requirements:</Text>
        <View style={styles.passwordRequirement}>
          <Icon 
            name={formData.password.length >= 6 ? "check-circle" : "radio-button-unchecked"} 
            size={16} 
            color={formData.password.length >= 6 ? COLORS.success : COLORS.textSecondary} 
          />
          <Text style={styles.passwordRequirementText}>At least 6 characters</Text>
        </View>
        <View style={styles.passwordRequirement}>
          <Icon 
            name={/\d/.test(formData.password) && /[a-zA-Z]/.test(formData.password) ? "check-circle" : "radio-button-unchecked"} 
            size={16} 
            color={/\d/.test(formData.password) && /[a-zA-Z]/.test(formData.password) ? COLORS.success : COLORS.textSecondary} 
          />
          <Text style={styles.passwordRequirementText}>Contains letters and numbers</Text>
        </View>
        <View style={styles.passwordRequirement}>
          <Icon 
            name={formData.password === formData.confirmPassword && formData.password ? "check-circle" : "radio-button-unchecked"} 
            size={16} 
            color={formData.password === formData.confirmPassword && formData.password ? COLORS.success : COLORS.textSecondary} 
          />
          <Text style={styles.passwordRequirementText}>Passwords match</Text>
        </View>
      </View>

                {/* Email Opt-in Checkbox */}
                <View style={styles.checkboxContainer}>
                  <Checkbox
                    status={formData.emailOptIn ? 'checked' : 'unchecked'}
                    onPress={() => handleInputChange('emailOptIn', !formData.emailOptIn)}
                    color={COLORS.primary}
                  />
                  <Text style={styles.checkboxText}>
                    (Optional) It's ok to send me emails with Acceilla updates, tips, special offers. You can opt out any time.
                  </Text>
                </View>

                {/* Terms and Conditions */}
                <View style={styles.termsContainer}>
                  <View style={styles.childProtectionNotice}>
                    <Icon name="info" size={16} color="#F59E0B" />
                    <Text style={styles.childProtectionText}>
                      Children under the age of 18 should use the children's version and account creation should be done with parent supervision to ensure child protection.
                    </Text>
                  </View>
                  
                  <Text style={styles.termsText}>
                    By clicking Create Account, you agree to Acceilla's{' '}
                    <Text style={styles.termsLink}>Terms of Service</Text> and have read the{' '}
                    <Text style={styles.termsLink}>Privacy Policy</Text>.
                  </Text>
                </View>

                <TouchableOpacity 
                  style={styles.signInLink}
                  onPress={() => navigation.navigate('Login')}>
                  <Text style={styles.signInText}>Already have an account? Sign In</Text>
                </TouchableOpacity>
              </View>
            </ScrollView>
          </View>
        );

      default:
        return null;
    }
  };

  return (
  <View style={styles.container}>
    {currentStep === 0 ? (
      // Step 0: Full-screen Authentication Method Selection
      <AuthMethodSelection
        navigation={navigation}
        onMethodSelect={handleAuthMethodSelect}
        selectedMethod={formData.authMethod}
        networkStatus={networkStatus}
        onNext={() => {
          if (formData.authMethod) {
            animateToStep(1);
          } else {
            Alert.alert('Selection Required', 'Please choose an authentication method to continue.');
          }
        }}
        onBack={() => navigation.goBack()}
      />
    ) : (
      // Steps 1-4: Existing multi-step registration form
      <>
        {/* Header */}
        <View style={styles.header}>
          <View style={styles.headerLeft} />
          <View style={styles.headerTitleContainer}>
            <Text style={styles.headerTitle}>Welcome to Acceilla</Text>
            <Text style={styles.headerSubtitle}>Create your account and get started</Text>
          </View>
          <View style={styles.headerRight} />
        </View>

        {/* Progress */}
        <View style={styles.progressContainer}>
          <View style={styles.progressHeader}>
            <Text style={styles.progressText}>
              Step {currentStep + 1} of 5
            </Text>
            <Text style={styles.progressPercentage}>
              {Math.round(getPersonalizedStepData(currentStep).progress * 100)}%
            </Text>
          </View>
          <View style={styles.progressBarContainer}>
            <View style={styles.progressBarBackground}>
              <View 
                style={[
                  styles.progressBarFill, 
                  { width: `${getPersonalizedStepData(currentStep).progress * 100}%` }
                ]} 
              />
            </View>
          </View>
        </View>

        {/* Step Header */}
        {renderStepHeader()}

        {/* Content */}
        <View style={styles.contentContainer}>
          <Animated.View 
            style={[
              styles.stepsWrapper,
              { transform: [{ translateX: slideAnim }] }
            ]}>
            {[0, 1, 2, 3, 4].map((_, index) => (
              <View key={index} style={styles.stepWrapper}>
                {index === currentStep && renderStep()}
              </View>
            ))}
          </Animated.View>
        </View>

        {/* Navigation */}
        <View style={styles.navigationContainer}>
          <TouchableOpacity
            onPress={prevStep}
            disabled={currentStep === 1} // Changed from 0 to 1
            style={[
              styles.customNavButton, 
              styles.outlinedButton,
              currentStep === 1 && styles.navButtonDisabled // Changed from 0 to 1
            ]}>
            <Icon name="arrow-back" size={18} color={currentStep === 1 ? "#CBD5E1" : COLORS.primary} />
            <Text style={[styles.navButtonText, styles.outlinedButtonText]}>Back</Text>
          </TouchableOpacity>

          <View style={styles.stepIndicators}>
            {[1, 2, 3, 4].map((stepNum, index) => ( // Changed to show steps 1-4 when not on step 0
              <View 
                key={stepNum}
                style={[
                  styles.stepIndicator,
                  (index + 1) === currentStep && styles.stepIndicatorActive,
                  (index + 1) < currentStep && styles.stepIndicatorCompleted
                ]}
              />
            ))}
          </View>

          <TouchableOpacity
            onPress={nextStep}
            disabled={loading}
            style={[styles.customNavButton, styles.containedButton]}>
            <Text style={[styles.navButtonText, styles.containedButtonText]}>
              {currentStep === 4 ? (loading ? 'Creating...' : 'Create Account') : 'Next'}
            </Text>
            {currentStep !== 4 && !loading && (
              <Icon name="arrow-forward" size={18} color="#FFFFFF" />
            )}
            {loading && currentStep === 4 && (
              <View style={styles.loadingSpinner}>
                {/* Add your loading indicator here */}
              </View>
            )}
          </TouchableOpacity>
        </View>
      </>
    )}

{/* Image Selection Modal - Exact copy from original */}
      <Modal
        animationType="slide"
        transparent={true}
        visible={showImageModal}
        onRequestClose={() => setShowImageModal(false)}>
        <TouchableOpacity 
          style={styles.modalOverlay}
          activeOpacity={1}
          onPress={() => setShowImageModal(false)}>
          
          <View style={styles.grassBackground} />
          
          <View style={styles.modalContainer}>
            <View style={styles.modalHeader}>
              <View style={styles.modalHandle} />
              <Text style={styles.modalTitle}>Select Profile Image</Text>
            </View>
            
            <ScrollView 
              style={styles.modalScrollView}
              contentContainerStyle={styles.modalScrollContent}
              showsVerticalScrollIndicator={true}
              persistentScrollbar={true}
              nestedScrollEnabled={true}
              bounces={true}>
              
              <TouchableOpacity 
                activeOpacity={1}
                onPress={(e) => e.stopPropagation()}>
                
                <View style={styles.modalOptionsContainer}>
                  <TouchableOpacity 
                    style={styles.modalOption}
                    onPress={selectImageFromCamera}
                    activeOpacity={0.7}>
                    <View style={styles.modalOptionIconContainer}>
                      <Icon name="camera-alt" size={28} color={COLORS.primary} />
                    </View>
                    <View style={styles.modalOptionTextContainer}>
                      <Text style={styles.modalOptionTitle}>Take Photo</Text>
                      <Text style={styles.modalOptionDescription}>Use your camera to take a new photo</Text>
                    </View>
                  </TouchableOpacity>
                  
                  <TouchableOpacity 
                    style={styles.modalOption}
                    onPress={selectImageFromGallery}
                    activeOpacity={0.7}>
                    <View style={styles.modalOptionIconContainer}>
                      <Icon name="photo-library" size={28} color={COLORS.primary} />
                    </View>
                    <View style={styles.modalOptionTextContainer}>
                      <Text style={styles.modalOptionTitle}>Choose from Gallery</Text>
                      <Text style={styles.modalOptionDescription}>Select an existing photo from your gallery</Text>
                    </View>
                  </TouchableOpacity>
                  
                  <TouchableOpacity 
                    style={[styles.modalOption]}
                    onPress={() => {
                      setFormData(prev => ({ ...prev, profileImage: null }));
                      setShowImageModal(false);
                    }}
                    activeOpacity={0.7}>
                    <View style={styles.modalOptionIconContainer}>
                      <Icon name="person" size={28} color={COLORS.primary} />
                    </View>
                    <View style={styles.modalOptionTextContainer}>
                      <Text style={styles.modalOptionTitle}>Use Avatar</Text>
                      <Text style={styles.modalOptionDescription}>Create a custom avatar with your initials</Text>
                    </View>
                  </TouchableOpacity>
                  
                  <TouchableOpacity 
                    style={[styles.modalOption, { opacity: 0.6 }]}
                    activeOpacity={0.7}>
                    <View style={styles.modalOptionIconContainer}>
                      <Icon name="emoji-emotions" size={28} color={COLORS.primary} />
                    </View>
                    <View style={styles.modalOptionTextContainer}>
                      <Text style={styles.modalOptionTitle}>Emoji Avatar</Text>
                      <Text style={styles.modalOptionDescription}>Create a fun emoji-based profile picture</Text>
                    </View>
                  </TouchableOpacity>
                </View>
                
                    <TouchableOpacity 
                    style={[styles.modalOption, { opacity: 0.6 }]}
                    activeOpacity={0.7}>
                <View style={styles.modalOptionIconContainer}>
                      <Icon name="sports" size={28} color={COLORS.primary} />
                    </View>
                    <View style={styles.modalOptionTextContainer}>
                      <Text style={styles.modalOptionTitle}>Sport Templates</Text>
                      <Text style={styles.modalOptionDescription}>Choose from pre-made sport-themed avatars (Coming Soon)</Text>
                    </View>
                  </TouchableOpacity>
                  
                  <TouchableOpacity 
                    style={[styles.modalOption, { opacity: 0.6 }]}
                    activeOpacity={0.7}>
                    <View style={styles.modalOptionIconContainer}>
                      <Icon name="color-lens" size={28} color={COLORS.primary} />
                    </View>
                    <View style={styles.modalOptionTextContainer}>
                      <Text style={styles.modalOptionTitle}>Custom Design</Text>
                      <Text style={styles.modalOptionDescription}>Design your own unique profile image (Coming Soon)</Text>
                    </View>
                  </TouchableOpacity>

                  <TouchableOpacity 
                    style={[styles.modalOption, { opacity: 0.6 }]}
                    activeOpacity={0.7}>
                    <View style={styles.modalOptionIconContainer}>
                      <Icon name="palette" size={28} color={COLORS.primary} />
                    </View>
                    <View style={styles.modalOptionTextContainer}>
                      <Text style={styles.modalOptionTitle}>Color Themes</Text>
                      <Text style={styles.modalOptionDescription}>Select from various color themes for your avatar</Text>
                    </View>
                  </TouchableOpacity>

                
                <TouchableOpacity 
                  style={styles.modalCancel}
                  onPress={() => setShowImageModal(false)}
                  activeOpacity={0.7}>
                  <Text style={styles.modalCancelText}>Cancel</Text>
                </TouchableOpacity>
                
                <View style={styles.modalBottomSpace} />
              </TouchableOpacity>
            </ScrollView>
          </View>
        </TouchableOpacity>
      </Modal>
    </View>
  );
};


const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F8FAFC',
  },
  header: {
  flexDirection: 'row',
  alignItems: 'center',
  justifyContent: 'space-between',
  paddingHorizontal: SPACING.lg,
  paddingVertical: SPACING.sm,
  paddingTop: Platform.OS === 'ios' ? 50 : SPACING.sm,
  backgroundColor: '#FFFFFF',
  elevation: 3,
  shadowColor: '#000',
  shadowOffset: { width: 0, height: 2 },
  shadowOpacity: 0.1,
  shadowRadius: 4,
  },
  headerLeft: {
  width: 40,
  },
  headerTitleContainer: {
  alignItems: 'center',
  flex: 1,
  },
  headerTitle: {
    fontSize: 20,
    color: COLORS.primary,
    fontWeight: '700',
    letterSpacing: 0.5,
  },
  headerSubtitle: {
    fontSize: 12,
    color: '#64748B',
    fontWeight: '500',
    marginTop: 2,
  },
  backButton: {
    padding: SPACING.sm,
    borderRadius: 20,
    backgroundColor: '#F1F5F9',
  },
  headerRight: {
    width: 40,
  },
  backButton: {
    padding: SPACING.sm,
    borderRadius: 20,
    backgroundColor: '#F1F5F9',
  },
  customNavButton: {
  flexDirection: 'row',
  alignItems: 'center',
  justifyContent: 'center',
  minWidth: 90,
  height: 40,
  paddingHorizontal: 16,
  borderRadius: 20,
  },
  outlinedButton: {
    borderWidth: 1,
    borderColor: COLORS.primary,
    backgroundColor: 'transparent',
  },
  containedButton: {
    backgroundColor: COLORS.primary,
  },
  sectionTitle: {
  fontSize: 18,
  color: '#1E293B',
  fontWeight: '700',
  marginBottom: SPACING.xs,
  textAlign: 'center',
},
sectionSubtitle: {
  fontSize: 14,
  color: '#64748B',
  textAlign: 'center',
  marginBottom: SPACING.lg,
  lineHeight: 20,
},
quickSelectContainer: {
  marginBottom: SPACING.md,
},
quickSelectTitle: {
  fontSize: 14,
  fontWeight: '600',
  color: '#475569',
  marginBottom: SPACING.sm,
},
quickSelectScroll: {
  marginBottom: SPACING.xs,
},
quickSelectChip: {
  marginRight: SPACING.sm,
  backgroundColor: '#F8FAFC',
},
quickSelectChipSelected: {
  backgroundColor: COLORS.primary,
},
quickSelectChipText: {
  fontSize: 12,
},
securityTipsContainer: {
  marginTop: SPACING.md,
  padding: SPACING.sm,
  backgroundColor: '#F8FAFC',
  borderRadius: 8,
  borderWidth: 1,
  borderColor: '#E2E8F0',
},
securityTip: {
  flexDirection: 'row',
  alignItems: 'flex-start',
  marginBottom: SPACING.xs,
},
securityTipText: {
  flex: 1,
  fontSize: 12,
  color: '#64748B',
  marginLeft: SPACING.xs,
  lineHeight: 16,
},
  navButtonText: {
    fontSize: 14,
    fontWeight: '600',
    marginHorizontal: 4,
  },
  outlinedButtonText: {
    color: COLORS.primary,
  },
  containedButtonText: {
    color: '#FFFFFF',
  },
  loadingSpinner: {
    marginLeft: 8,
  },
  headerTitle: {
    ...TEXT_STYLES.h3,
    color: '#1E293B',
    fontWeight: '700',
  },
  headerRight: {
    width: 40,
  },
  progressContainer: {
    paddingHorizontal: SPACING.lg,
    paddingVertical: SPACING.md,
    backgroundColor: '#FFFFFF',
    borderBottomWidth: 1,
    borderBottomColor: '#E2E8F0',
  },
  progressHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: SPACING.sm,
  },
  progressText: {
    ...TEXT_STYLES.body,
    color: '#475569',
    fontWeight: '600',
  },
  progressPercentage: {
    ...TEXT_STYLES.body,
    color: '#3B82F6',
    fontWeight: '700',
  },
  progressBarContainer: {
    width: '100%',
  },
  progressBarBackground: {
    height: 6,
    backgroundColor: '#E2E8F0',
    borderRadius: 3,
    overflow: 'hidden',
  },
  progressBarFill: {
    height: '100%',
    backgroundColor: '#3B82F6',
    borderRadius: 3,
  },
  
  // Step Header
  stepHeader: {
    alignItems: 'center',
    paddingHorizontal: SPACING.lg,
    paddingVertical: SPACING.sm,
    backgroundColor: '#FFFFFF',
  },
  stepIconContainer: {
    width: 64,
    height: 64,
    borderRadius: 32,
    backgroundColor: '#EFF6FF',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: SPACING.sm,
    borderWidth: 2,
    borderColor: '#DBEAFE',
  },
  stepHeaderImage: {
    borderWidth: 2,
    borderColor: '#DBEAFE',
  },
  stepHeaderCameraIcon: {
    position: 'absolute',
    bottom: 0,
    right: 0,
    backgroundColor: COLORS.primary,
    borderRadius: 12,
    padding: SPACING.xs,
    elevation: 3,
  },
  stepHeaderUploadButton: {
    marginTop: SPACING.sm,
    borderColor: COLORS.primary,
  },
  stepTitle: {
    ...TEXT_STYLES.h2,
    color: '#1E293B',
    fontWeight: '700',
    marginBottom: SPACING.xs,
  },
  stepSubtitle: {
    ...TEXT_STYLES.body,
    color: '#64748B',
    textAlign: 'center',
  },
  
  contentContainer: {
    flex: 1,
    overflow: 'hidden',
    backgroundColor: '#F8FAFC',
  },
  stepsWrapper: {
    flexDirection: 'row',
    height: '100%',
  },
  stepWrapper: {
    width: screenWidth,
    height: '100%',
  },
  stepScrollContainer: {
    flex: 1,
    paddingHorizontal: SPACING.lg,
  },
  stepScrollContent: {
    paddingVertical: SPACING.sm,
    paddingBottom: SPACING.md,
  },
  stepScrollContentCompact: {
    paddingVertical: SPACING.xs,
    paddingBottom: SPACING.sm,
  },
  stepContainer: {
    flex: 1,
  },
  
  formSection: {
    flex: 1,
  },
  nameRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  
  // Enhanced input validation styles - keeping it clean
  input: {
    marginBottom: SPACING.sm,
    backgroundColor: '#FFFFFF',
  },
  halfInput: {
    width: '48%',
  },
  errorRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: SPACING.xs,
  },
  halfError: {
    width: '48%',
  },
  errorText: {
    marginTop: -SPACING.xs,
    marginBottom: SPACING.xs,
  },
  
  // Username controls - clean and minimal
  usernameControls: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginTop: SPACING.xs,
    marginBottom: SPACING.sm,
  },
  autoGeneratedBadge: {
    backgroundColor: '#E0F2FE',
    height: 28,
  },
  autoGeneratedBadgeText: {
    color: '#0369A1',
    fontSize: 10,
    fontWeight: '500',
  },
  regenerateButton: {
    borderRadius: 15,
  },
  regenerateButtonLabel: {
    fontSize: 11,
    color: COLORS.primary,
  },
  sectionTitleCompact: {
    fontSize: 16,
    color: '#1E293B',
    fontWeight: '700',
    marginTop: SPACING.xs,
    marginBottom: SPACING.md,
    textAlign: 'center',
  },
  userTypeOptionCompact: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: SPACING.sm,
    paddingHorizontal: SPACING.sm,
    borderRadius: 10,
    borderWidth: 2,
    borderColor: '#E2E8F0',
    backgroundColor: '#FFFFFF',
    marginBottom: SPACING.xs,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.03,
    shadowRadius: 1,
  },
  userTypeOptionSelected: {
    borderColor: '#3B82F6',
    backgroundColor: '#EFF6FF',
    elevation: 4,
    shadowOpacity: 0.15,
  },
  userTypeIconContainerCompact: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: '#F1F5F9',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: SPACING.sm,
  },
  userTypeTextContainer: {
    flex: 1,
  },
  userTypeLabelCompact: {
    fontSize: 14,
    fontWeight: '600',
    color: '#1E293B',
  },
  userTypeLabelSelected: {
    color: '#3B82F6',
  },
  userTypeDescriptionCompact: {
    fontSize: 12,
    color: '#64748B',
    marginTop: 2,
  },
  passwordStrength: {
    marginTop: SPACING.sm,
    padding: SPACING.sm,
    borderRadius: 8,
    backgroundColor: '#FFFFFF',
    borderWidth: 1,
    borderColor: '#E2E8F0',
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.03,
    shadowRadius: 1,
  },
  passwordStrengthTitle: {
    fontSize: 13,
    fontWeight: '600',
    color: '#1E293B',
    marginBottom: SPACING.xs,
  },
  passwordRequirement: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
  },
  passwordRequirementText: {
    fontSize: 12,
    color: '#64748B',
    marginLeft: SPACING.xs,
  },
  
  // New styles for checkbox and terms
  checkboxContainer: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    marginTop: SPACING.md,
    paddingHorizontal: SPACING.sm,
  },
  checkboxText: {
    flex: 1,
    fontSize: 13,
    color: '#64748B',
    marginLeft: SPACING.xs,
    lineHeight: 18,
  },
  
  termsContainer: {
    marginTop: SPACING.lg,
    paddingHorizontal: SPACING.sm,
  },
  childProtectionNotice: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    backgroundColor: '#FEF3C7',
    padding: SPACING.sm,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#F59E0B',
    marginBottom: SPACING.md,
  },
  childProtectionText: {
    flex: 1,
    fontSize: 12,
    color: '#92400E',
    marginLeft: SPACING.xs,
    lineHeight: 16,
  },
  termsText: {
    fontSize: 12,
    color: '#64748B',
    lineHeight: 16,
    textAlign: 'center',
  },
  termsLink: {
    color: '#3B82F6',
    fontWeight: '600',
  },
  
  signInLink: {
    alignItems: 'center',
    marginTop: SPACING.md,
    paddingVertical: SPACING.sm,
  },
  signInText: {
    fontSize: 14,
    color: '#3B82F6',
    fontWeight: '600',
  },
  navigationContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: SPACING.lg,
    paddingVertical: SPACING.md,
    backgroundColor: '#FFFFFF',
    elevation: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    borderTopWidth: 1,
    borderTopColor: '#E2E8F0',
  },
  navButton: {
    minWidth: 90,
    borderRadius: 20,
  },
  navButtonDisabled: {
    opacity: 0.4,
  },
  navButtonContent: {
    height: 40,
  },
  stepIndicators: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    flex: 1,
  },
  stepIndicator: {
    width: 8,
    height: 8,
    borderRadius: 4,
    backgroundColor: '#CBD5E1',
    marginHorizontal: 4,
  },
  stepIndicatorActive: {
    backgroundColor: COLORS.primary,
    transform: [{ scale: 1.2 }],
  },
  stepIndicatorCompleted: {
    backgroundColor: COLORS.success,
  },

  // Modal Styles
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.6)',
    justifyContent: 'flex-end',
    alignItems: 'center',
  },
  grassBackground: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(34, 139, 34, 0.15)',
    ...(Platform.OS === 'web' && {
      backgroundImage: `
        radial-gradient(circle at 25% 25%, rgba(34, 139, 34, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 75% 75%, rgba(50, 205, 50, 0.08) 0%, transparent 50%),
        radial-gradient(circle at 75% 25%, rgba(34, 139, 34, 0.06) 0%, transparent 50%),
        radial-gradient(circle at 25% 75%, rgba(107, 142, 35, 0.1) 0%, transparent 50%)
      `,
      backgroundSize: '40px 40px, 60px 60px, 80px 80px, 100px 100px',
    }),
  },
  modalContainer: {
    width: Platform.OS === 'web' ? '90%' : '100%',
    maxWidth: Platform.OS === 'web' ? 500 : undefined,
    height: screenHeight * 0.85,
    backgroundColor: 'rgba(255, 255, 255, 0.98)',
    borderRadius: Platform.OS === 'web' ? 20 : undefined,
    borderTopLeftRadius: Platform.OS !== 'web' ? 25 : undefined,
    borderTopRightRadius: Platform.OS !== 'web' ? 25 : undefined,
    marginBottom: Platform.OS === 'web' ? 20 : 0,
    ...(Platform.OS === 'web' && {
      boxShadow: '0 20px 60px rgba(0, 0, 0, 0.3)',
    }),
    elevation: 10,
    overflow: 'hidden',
  },
  modalHeader: {
    alignItems: 'center',
    paddingTop: SPACING.md,
    paddingBottom: SPACING.md,
    backgroundColor: 'rgba(255, 255, 255, 0.95)',
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 0, 0, 0.05)',
  },
  modalHandle: {
    width: 40,
    height: 4,
    backgroundColor: COLORS.textSecondary,
    borderRadius: 2,
    marginBottom: SPACING.md,
    opacity: 0.3,
  },
  modalTitle: {
    ...TEXT_STYLES.h3,
    color: COLORS.text,
    fontWeight: '600',
  },
  modalScrollView: {
    flex: 1,
    backgroundColor: 'transparent',
  },
  modalScrollContent: {
    paddingHorizontal: SPACING.lg,
    paddingVertical: SPACING.md,
    flexGrow: 1,
    paddingBottom: 60,
  },
  modalOptionsContainer: {
    marginBottom: SPACING.lg,
  },
  modalOption: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: SPACING.lg,
    paddingHorizontal: SPACING.lg,
    borderRadius: 16,
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    marginBottom: SPACING.md,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    borderWidth: 1,
    borderColor: 'rgba(0, 0, 0, 0.05)',
  },
  modalOptionIconContainer: {
    width: 50,
    height: 50,
    borderRadius: 25,
    backgroundColor: `${COLORS.primary}15`, // 15% opacity
    alignItems: 'center',
    justifyContent: 'center',
  },
  modalOptionTextContainer: {
    flex: 1,
    marginLeft: SPACING.lg,
  },
  modalOptionTitle: {
    ...TEXT_STYLES.body,
    fontWeight: '600',
    color: COLORS.text,
    marginBottom: SPACING.xs,
  },
  modalOptionDescription: {
    ...TEXT_STYLES.caption,
    color: COLORS.textSecondary,
    lineHeight: 16,
  },
  modalCancel: {
    alignItems: 'center',
    paddingVertical: SPACING.lg,
    paddingHorizontal: SPACING.lg,
    borderRadius: 16,
    backgroundColor: 'rgba(255, 0, 0, 0.08)',
    marginTop: SPACING.md,
  },
  modalCancelText: {
    ...TEXT_STYLES.body,
    color: '#d32f2f',
    fontWeight: '600',
    fontSize: 16,
  },
  modalBottomSpace: {
    height: 40,
  },
});

export default MultiStepRegisterScreen;